<?php

/**
 * @file
 * Management and utility for petitions.
 *
 * WARNING: THIS MODULE IS GOING TO BE REMOVED BEFORE 7.x-3.0.
 */

// @todo Move legacy functions into here as they are flagged, renamed, or
// refactored throughout the code base.
require_once dirname(__FILE__) . '/wh_petitions.mongo2mysql.inc';

/**
 * @todo: Note: Trending used to be a link on the /petitions page.
 * This has been commented out, but the code is still here because we're
 * concerned about breaking something else by removing it. Please revisit.
 */

/* Petition Workflow
 *
 * -User clicks to continue after step 1 of the create a petition
 *  form - petition is saved as draft.
 *   -Petition can only be viewed by the creator in the create a petition
 *    form process and their dashboard
 * -User clicks to publish petition on step 4 of create a
 *  petition form - petition is published and made private.
 *   -Petition is only visible by direct url
 * -Petition retrieves X ( public_signatures ) signatures
 *  within X days ( review_timeframe ), is made public.
 *    -Petition is available in lists and by direct url
 * -Petition does not receive X ( public_signatures ) signatures
 *  within X days ( review_timeframe ) - is made closed
 *    -Petition is only available by direct url.
 * -Petition receives x ( review_signatures ) signatures
 *  within X days ( review_timeframe ) - is made under review
 *   -Can still receive signatures and appears in lists until
 *    responded to, even if that's past the number of days
 *    it had ( review_timeframe )
 * -Petition receives a response - changed to reviewed status.
 *   -Petition can no longer receive signatures and is removed from lists.
 *    Available by direct url and from the response page
 * -Petition receives X reports of abuse, made flagged status.
 *  Only available via direct url.
 */

/********************* STATUSES ************************/

/**
 * Constants for Petition Statuses
 */

/**
 * Saved as a draft, only visible to creator
 */
define('WH_PETITION_STATUS_DRAFT', 0);

/**
 * Published, but does not have the required number of
 * signatures to become public, only visible by direct url
 */
define('WH_PETITION_STATUS_PRIVATE', 1);

/**
 * Has the required number of signatures to become public,
 * visible everywhere on site
 */
define('WH_PETITION_STATUS_PUBLIC', 2);

/**
 * Did not receive the required number of signatures to receive a
 * response, only visible by direct url
 */
define('WH_PETITION_STATUS_CLOSED', 3);

/**
 * Has received the required number of signatures, visible on site
 */
define('WH_PETITION_STATUS_UNDER_REVIEW', 4);

/**
 * Has received a response
 */
define('WH_PETITION_STATUS_REVIEWED', 5);

 /**
  * Has been removed from lists by administrative action on the dashboard.
  * This may have been prompted by it exceeding the threshold for the number of
  * abuse flags.  It shows on the dashboard as "removed".
  */
define('WH_PETITION_STATUS_FLAGGED', 6);

/**
 * Returns an array of status id's that are to be treated as signable.
 *
 * If a petition has an actual status (not the friendly display status) that
 * is contained in the array returned by this function, it can be considered
 * 'signable' and  may be returned as such by the API.  The following statuses
 * are considered signable:
 *  - WH_PETITION_STATUS_PRIVATE: Is signable but only visible by direct link.
 *  - WH_PETITION_STATUS_PUBLIC: Is public and signable.
 *  - WH_PETITION_STATUS_UNDER_REVIEW: Has reached enough signatures for a
 *    response, but has not been responded to, so can get more signatures.
 *
 * @return array
 *   Array of petition status id's considered signable
 */
function wh_petitions_signable_statuses() {
  return array(
    WH_PETITION_STATUS_PRIVATE,
    WH_PETITION_STATUS_PUBLIC,
    WH_PETITION_STATUS_UNDER_REVIEW,
  );
}

/**
 * Returns an array of status IDs that are all the possible statuses.
 *
 * @return array
 *   Array of petition all defined petitions status IDs.
 */
function wh_petitions_all_statuses() {
  return array(
    WH_PETITION_STATUS_DRAFT,
    WH_PETITION_STATUS_PRIVATE,
    WH_PETITION_STATUS_PUBLIC,
    WH_PETITION_STATUS_CLOSED,
    WH_PETITION_STATUS_UNDER_REVIEW,
    WH_PETITION_STATUS_REVIEWED,
    WH_PETITION_STATUS_FLAGGED,
  );
}

/**
 * Returns an array of status id's that are to be treated as public.
 *
 * If a petition has an actual status (not the friendly display status) that
 * is contained in the array returned by this function, it can be considered
 * 'public' and  may be returned as such by the API.  The following statuses are
 * considered public:
 *  - WH_PETITION_STATUS_PUBLIC: By definition this is public.
 *  - WH_PETITION_STATUS_UNDER_REVIEW:  No action has been taken on this.
 *  - WH_PETITION_STATUS_REVIEWED: Has been reviewed and responded to.
 *  - WH_PETITION_STATUS_CLOSED: Is closed but should still be visible.
 *
 * @return array
 *   Array of petition status id's considered public.
 */
function wh_petitions_public_statuses() {
  return array(
    WH_PETITION_STATUS_PUBLIC,
    WH_PETITION_STATUS_UNDER_REVIEW,
    WH_PETITION_STATUS_REVIEWED,
    WH_PETITION_STATUS_CLOSED,
  );
}

/**
 * Returns an array of status id's that indicate an "open" petition.
 *
 * @return array
 *   Array of petition status id's considered open.
 */
function wh_petitions_open_statuses() {
  return array(
    WH_PETITION_STATUS_PUBLIC,
    WH_PETITION_STATUS_UNDER_REVIEW
  );
}

/**
 * Returns an array of status id's that are to be treated as unpublished.
 *
 * @return array
 *   Array of petition status id's considered unpublished.
 */
function wh_petitions_unpublished_statuses() {
  return array(
    WH_PETITION_STATUS_FLAGGED,
    WH_PETITION_STATUS_DRAFT
  );
}

/**
 * Constants for Response Statuses
 */

// Petition has not been reviewed.
define('WH_PETITION_RESPONSE_STATUS_UNANSWERED', 0);

// Petition is awaiting action.
define('WH_PETITION_RESPONSE_STATUS_PENDING', 1);

// Petition has been responded to.
define('WH_PETITION_RESPONSE_STATUS_ANSWERED', 2);

/**
 * Misc Constants
 */

// Petitions to display per page on the Open Petitions page.
define('WH_PETITION_PETITIONS_PER_PAGE', 20);

define('WH_PETITION_NICE_URL', 'petition/[petition:title]');

/**
 * Petitions signing methods
 */

/**
 * Registration required.
 */
define('WH_PETITIONS_SIGNING_METHOD_REGISTRATION_REQUIRED', 0);

/**
 * Simplified signing.
 */
define('WH_PETITIONS_SIGNING_METHOD_SIMPLIFIED_SIGNING', 1);

/**
 * Returns the title associated with a status.
 */
function wh_petitions_display_status_name($status_id, $type = 'petition') {
  switch ($type) {
    case 'petition':
      switch ($status_id) {
        case WH_PETITION_STATUS_DRAFT:
          return t('Draft');

        case WH_PETITION_STATUS_PRIVATE:
          return t('Private');

        case WH_PETITION_STATUS_PUBLIC:
          return t('Public');

        case WH_PETITION_STATUS_CLOSED:
          return t('Archived');

        case WH_PETITION_STATUS_UNDER_REVIEW:
          return t('Under Review');

        case WH_PETITION_STATUS_REVIEWED:
          return t('Reviewed');

        case WH_PETITION_STATUS_FLAGGED:
          return t('Removed');

        default:
          return '';
      }
    case 'response':
      switch ($status_id) {
        case WH_PETITION_RESPONSE_STATUS_UNANSWERED:
          return t('Unanswered');

        case WH_PETITION_RESPONSE_STATUS_PENDING:
          return t('Awaiting Action');

        case WH_PETITION_RESPONSE_STATUS_ANSWERED:
          return t('Responded');

        default:
          return '';
      }
    default:
      return '';
  }
}

/********************* DRUPAL HOOKS / BLOCKS ************************/

/**
 * Implements hook_perm().
 *
 * Creates three permissions:
 *  - administer permission settings: needed to access the
 *    admin/config/system/petitions page
 *  - adminster petitions: needed to access the admin/petitions
 *    page and perform actions such as bookmarking or
 *    featuring petitions.
 *  - create petition: needed to be able to create a petition.
 */
function wh_petitions_permission() {
  return array(
    'administer petition settings' => array(
      'title' => t('Administer petition settings'),
      'description' => t('Change petition and signature levels, administer block and page text.'),
    ),
    'administer petitions' => array(
      'title' => t('Administer petitions'),
      'description' => '',
    ),
    'create petition' => array(
      'title' => t('Create a petition'),
      'description' => '',
    ),
  );
}

/**
 * Implements modulename_preprocess().
 *
 * Insert variable into module template files.
 */
function wh_petitions_preprocess(&$variables, $hook) {
  global $base_url;
  $variables['path_to_petitions44'] = $base_url . '/' . drupal_get_path('theme', 'petitions44');
}

/**
 * Implements hook_menu().
 */
function wh_petitions_menu() {
  // Admin - Petition Tool Settings.
  $items['admin/config/system/petitions'] = array(
    'title' => 'Petition Tool Settings',
    'description' => 'Manage petition settings and text.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wh_petitions_admin_petition_settings'),
    'access arguments' => array('administer petition settings'),
    'weight' => -10,
    'file' => 'wh_petitions.admin.inc',
    'type' => MENU_NORMAL_ITEM,
  );

  // Admin - Petition Tool Main Settings.
  $items['admin/config/system/petitions/main'] = array(
    'title' => 'Petition Tool Settings',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  // Admin - Petition Tool Email Settings.
  $items['admin/config/system/petitions/email'] = array(
    'title' => 'Petition Tool Email Settings',
    'description' => 'Manage petition emails .',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wh_petitions_admin_petition_email_settings'),
    'access arguments' => array('administer petition settings'),
    'weight' => 10,
    'file' => 'wh_petitions.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );

  // Admin - Petition Dashboard.
  $items['admin/petitions'] = array(
    'title' => 'Petitions',
    'description' => 'Administer petitions.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wh_petitions_admin_petitions'),
    'access arguments' => array('administer petitions'),
    'weight' => -10,
    'file' => 'wh_petitions.admin.inc',
    'type' => MENU_NORMAL_ITEM,
  );
  $items['admin/petitions/petitions'] = array(
    'title' => 'Petitions',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  // Admin - Petition Dashboard.
  $items['admin/petitions/download_signatures/%'] = array(
    'title' => 'Download Signatures',
    'description' => 'Download petition signatures.',
    'page callback' => 'wh_petitions_download_signatures_run_batch',
    'page arguments' => array(3),
    'access arguments' => array('administer petitions'),
    'weight' => -10,
    'file' => 'wh_petitions.admin.inc',
  );

  // Admin - Petition Dashboard.
  $items['admin/petitions/download_signatures/%/%'] = array(
    'title' => 'Download Signatures',
    'description' => 'Download petition signatures.',
    'page callback' => 'wh_petitions_download_signatures_run_batch',
    'page arguments' => array(3, 4),
    'access arguments' => array('administer petitions'),
    'weight' => -10,
    'file' => 'wh_petitions.admin.inc',
  );

  // Admin - Petition Dashboard.
  $items['admin/petitions/download_signatures_finish/%/%'] = array(
    'title' => 'Download Signatures',
    'description' => 'Download petition signatures.',
    'page callback' => 'wh_petitions_download_signatures',
    'page arguments' => array(3, 4),
    'access arguments' => array('administer petitions'),
    'weight' => -10,
    'file' => 'wh_petitions.admin.inc',
  );

  // Admin - Petition Dashboard.
  $items['admin/petitions/settings'] = array(
    'title' => 'Settings',
    'description' => 'Administer petitions.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wh_petitions_admin_petitions_settings_form'),
    'access arguments' => array('administer petitions'),
    'weight' => 10,
    'file' => 'wh_petitions.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );

  // Admin - Petition Removal.
  $items['remove-mongo-petition'] = array(
    'title' => 'Petition Removal',
    'description' => 'Form to remove petitions',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wh_petitions_removal_form'),
    'access arguments' => array('administer petitions'),
    'weight' => 10,
    'file' => 'wh_petitions_removal.inc',
    'type' => MENU_CALLBACK,
  );

  // Admin - AJAX callbacks.
  $items['admin/bookmark/%'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_bookmark_petitions',
    'page arguments' => array(2),
    'access arguments' => array('administer petitions'),
    'file' => 'wh_petitions.admin.inc',
  );
  $items['admin/featured/%'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_feature_petitions',
    'page arguments' => array(2),
    'access arguments' => array('administer petitions'),
    'file' => 'wh_petitions.admin.inc',
  );
  $items['admin/remove-lists/%'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_remove_lists',
    'page arguments' => array(2),
    'access arguments' => array('administer petitions'),
    'file' => 'wh_petitions.admin.inc',
  );
  $items['admin/override-status/%'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_override_status',
    'page arguments' => array(2),
    'access arguments' => array('administer petitions'),
    'file' => 'wh_petitions.admin.inc',
  );

  // Autocomplete field for Petitions on the Apply Response form.
  $items['response-autocomplete'] = array(
    'page callback' => 'wh_petitions_response_autocomplete',
    'page arguments' => array(),
    'access arguments' => array('administer petitions'),
    'type' => MENU_CALLBACK,
    'file' => 'wh_petitions.admin.inc',
  );

  // Petition Detail page.
  $items['petition/detail/%'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_petition_detail',
    'page arguments' => array(2),
    'access arguments' => array('access content'),
    'file' => 'wh_petitions.pages.inc',
  );
  // Petition Detail for Nice URL.
  $items['petition/%'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_petition_detail_niceurl',
    'page arguments' => array(1),
    'access arguments' => array('access content'),
    'file' => 'wh_petitions.pages.inc',
  );

  // Email A Petition callbacks.
  $items['petition/email/%'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_email_petition',
    'page arguments' => array(2),
    'access arguments' => array('access content'),
    'file' => 'wh_petitions.pages.inc',
  );
  $items['petition/email_frame/%'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_email_petition_frame',
    'page arguments' => array(2),
    'access arguments' => array('access content'),
    'file' => 'wh_petitions.pages.inc',
  );
  $items['petition/email_thank/%'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_email_petition_thank_you',
    'page arguments' => array(2),
    'access arguments' => array('access content'),
    'file' => 'wh_petitions.pages.inc',
  );

  // Iframe with the create a petition form inside.
  $items['petitions/create'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_create_petition_iframe_html',
    'page arguments' => array(),
    'access arguments' => array('access content'),
    'file' => 'wh_petitions.form.inc',
    'weight' => 1,
  );

  // Create A Petition Form ( access control done in callback function ).
  $items['petition/create'] = array(
    'title' => 'Create a Petition',
    'description' => 'A menu link to create a petition section.',
    'page callback' => 'wh_petitions_create_petition_iframe',
    'page arguments' => array('wh_petitions_create_petition'),
    'access arguments' => array('access content'),
    'file' => 'wh_petitions.form.inc',
    'weight' => 16,
    'menu_name' => 'petitions-menu',
  );

  // Open Petitions section.
  $items['petitions'] = array(
    'title' => 'Open Petitions',
    'description' => 'A menu link to open petitions sections.',
    'page callback' => 'wh_petitions_show_petitions',
    'page arguments' => array(),
    'access arguments' => array('access content'),
    'file' => 'wh_petitions.pages.inc',
    'weight' => 17,
    'menu_name' => 'petitions-menu',
  );

  // User Dashboard ( access control done in page callback function ).
  $items['dashboard'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_user_dashboard',
    'access arguments' => array('access content'),
    'file' => 'wh_petitions.pages.inc',
  );

  // More Signatures AJAX call.
  $items['signatures/more/%/%/%/%'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_more_signatures',
    'page arguments' => array(2, 3, 4, 5),
    'access arguments' => array('access content'),
    'file' => 'wh_petitions.pages.inc',
  );

  // More Signatures AJAX call (no last_id argument).
  $items['signatures/more/%/%/%'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_more_signatures',
    'page arguments' => array(2, 3, NULL, 4),
    'access arguments' => array('access content'),
    'file' => 'wh_petitions.pages.inc',
  );

  // More Petitions AJAX call.
  $items['petitions/more/%/%/%/%'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_more_petitions',
    'page arguments' => array(2, 3, 4, 5),
    'access arguments' => array('access content'),
    'file' => 'wh_petitions.pages.inc',
  );

  // Report as Inappropriate modal AJAX call.
  $items['petition/inappropriate/%'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_inappropriate_modal',
    'page arguments' => array(2, 3),
    'access arguments' => array('access content'),
    'file' => 'wh_petitions.form.inc',
  );

  // Delete Petition callback.
  $items['petition/delete/%'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_delete_modal',
    'page arguments' => array(2),
    'access arguments' => array('access content'),
    'file' => 'wh_petitions.form.inc',
  );

  // Delete Petition Page callback.
  $items['petition/deleted'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_deleted_page',
    'page arguments' => array(),
    'access arguments' => array('access content'),
    'file' => 'wh_petitions.pages.inc',
  );

  // Sign Petition AJAX call.
  $items['petition/sign/%'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_sign_modal',
    'page arguments' => array(2),
    'access arguments' => array('access content'),
    'file' => 'wh_petitions.form.inc',
  );

  // Add Comment Form.
  $items['petition/add/comment/%'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_add_comment_form',
    'page arguments' => array(3),
    'access arguments' => array('access content'),
    'file' => 'wh_petitions.form.inc',
  );

  // Add Comment AJA callback.
  $items['petition/comment/%'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_add_comment',
    'page arguments' => array(2),
    'access arguments' => array('access content'),
    'file' => 'wh_petitions.form.inc',
  );

  // Filter Issue Form Standalone Page
  // ( for compliance - they're in hidden divs that use JS normally )
  $items['filter-issues'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_filter_issue_standalone',
    'page arguments' => array(),
    'access arguments' => array('access content'),
    'file' => 'wh_petitions.form.inc',
  );

  // Search Form Standalone Page
  // ( for compliance - they're in hidden divs that use JS normally )
  $items['filter-search'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_filter_search_standalone',
    'page arguments' => array(),
    'access arguments' => array('access content'),
    'file' => 'wh_petitions.form.inc',
  );

  // Filter/Search results callback.
  $items['filter/results/petitions'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_filter_results',
    'page arguments' => array(),
    'access arguments' => array('access content'),
    'file' => 'wh_petitions.form.inc',
  );

  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function wh_petitions_menu_alter(&$items) {
  $items['responses']['menu_name'] = 'petitions-menu';
  $items['responses']['weight'] = 30;

  $site_frontpage = variable_get('site_frontpage', FALSE);
  if ($site_frontpage == 'homepage') {
    $items['homepage']['menu_name'] = 'petitions-menu';
    $items['homepage']['weight'] = -1;
  }

  // Set access callback for node operations to our custom callback.
  $items['node/add/petition']['access callback'] = 'wh_petitions_petition_access';
  $items['node/%node']['access callback'] = 'wh_petitions_petition_access';
  $items['node/%node/edit']['access callback'] = 'wh_petitions_petition_access';
  $items['node/%node/delete']['access callback'] = 'wh_petitions_petition_access';

  // @todo: Get rid of these if feeds module gets disabled or we actually start using it.
  if (module_exists('feeds')) {
    $items['node/%/log']['access callback'] = FALSE;
    $items['node/%/delete-items']['access callback'] = FALSE;
    $items['node/%/import']['access callback'] = FALSE;
    $items['node/%/unlock']['access callback'] = FALSE;
  }

  if (module_exists('devel')) {
    $items['node/%node/devel']['access callback'] = '_wh_petitions_user_access';
  }

}

/**
 * Implements hook_theme().
 */
function wh_petitions_theme() {
  return array(
    // Thank You Page after a user has published a petition.
    'wh_petitions_page_thank_you' => array(
      'arguments' => array(),
      'template' => 'templates/wh-petitions-page-thank-you',
    ),
    // Petition Detail Page.
    'wh_petitions_page_petition' => array(
      'arguments' => array(),
      'template' => 'templates/wh-petitions-page-petition',
    ),
    // Page a user sees after they delete a petition.
    'wh_petitions_page_deleted' => array(
      'arguments' => array(),
      'template' => 'templates/wh-petitions-page-deleted',
    ),
    // Generic archived petition page.
    'wh_petitions_page_archived' => array(
      'arguments' => array(),
      'template' => 'templates/wh-petitions-page-archived',
    ),
    // User Dashboard page.
    'wh_petitions_user_dashboard' => array(
      'arguments' => array(),
      'template' => 'templates/wh-petitions-page-user-dashboard',
    ),
    // Signatures display on a petition detail page.
    'wh_petitions_display_signatures' => array(
      'arguments' => array(),
      'template' => 'templates/wh-petitions-display-signatures',
    ),
    // Petition info at the top of a petition page,
    // last page of create a petition.
    'wh_petitions_display_petition_info' => array(
      'arguments' => array(),
      'template' => 'templates/wh-petitions-display-petition-info',
    ),
    // Open Petitions page.
    'wh_petitions_display_petition_page' => array(
      'arguments' => array(),
      'template' => 'templates/wh-petitions-page-open-petitions',
    ),
    // List view display of a petition.
    'wh_petitions_display_list_petition' => array(
      'arguments' => array(),
      'template' => 'templates/wh-petitions-display-list-petition',
    ),
    // Header on Create A Petition section.
    'wh_petitions_create_header' => array(
      'arguments' => array(),
      'template' => 'templates/wh-petitions-create-header',
    ),
    // Renders the By The Numbers block body.
    'wh_petitions_by_the_numbers' => array(
      'arguments' => array(),
      'template' => 'templates/wh-petitions-by-the-numbers',
    ),
    // Displays the title field on the create a petition form.
    'wh_petition_title' => array(
      'render element' => 'element',
    ),
  );
}

/**
 * Implements hook_preprocess_node().
 *
 * Adds variables for the response node page, including the petitions that are associated with this node.
 */
function wh_petitions_preprocess_node(&$vars) {
  global $user;
  global $base_url;
  if ($vars['node']->type == 'petition') {
    $logged_in = ($user->uid > 0) ? TRUE : FALSE;
    $login_required = (variable_get('petitions_signing_method', WH_PETITIONS_SIGNING_METHOD_REGISTRATION_REQUIRED) == WH_PETITIONS_SIGNING_METHOD_REGISTRATION_REQUIRED) ? TRUE : FALSE;

    $node = $vars['node'];
    $lang = $node->language;
    $nid = $node->nid;
    $petition_title = $node->title;
    drupal_set_title($node->title);
    $body = $node->body[$lang][0]['value'];
    $short_url = empty($node->field_short_url[$lang][0]['value']) ? '' : $node->field_short_url[$lang][0]['value'];
    // Set as published date, or FALSE if empty.
    if (empty($node->field_timestamp_published[$lang][0]['value'])) {
      $date_published = FALSE;
    }
    else {
      $date_published = $node->field_timestamp_published[$lang][0]['value'];
    }
    $review_timeframe_days = $node->field_petition_review_timeframe[$lang][0]['value'];
    $end_date = strtotime('+' . $review_timeframe_days . ' days', $date_published);
    $end_date = date("F d, Y", $end_date);
    $date_published = date("M d, Y", $date_published);
    $total_needed = $node->field_petition_response_sign[$lang][0]['value'];
    // Count of number of times this petition has been signed.
    $signature_total = $node->field_petition_signature_count[$lang][0]['value'];
    // Count of signatures currently displayed on petition page.
    $signature_count = 0;
    $signatures_needed = $total_needed - $signature_total;
    // Initialize some variables we'll set later.
    $agency_name = '';
    $agency_seal = '';
    $response_title = '';
    $response_body = '';
    $response_audio = '';
    $response_video = '';
    $issues = '';
    $flagged = FALSE;
    $archived = FALSE;
    $responded = FALSE;
    $path = drupal_get_path_alias('node/' . $nid);
    if ($signatures_needed < 0) {
      $signatures_needed = 0;
    }

    // Petition's Legacy ID,  or FALSE if empty.
    $legacy_id = (!empty($node->field_legacy_id[$node->language][0]['value']) ? $node->field_legacy_id[$node->language][0]['value'] : FALSE);

    $petition_id = !empty($legacy_id) ? $legacy_id : $nid;

    // Populate linked, comma separated 'Issues' variable.
    if (!empty($node->field_petition_issues[$node->language])) {
      $issues_array = $node->field_petition_issues[$node->language];
      $issues_count = count($issues_array);
      $first_issue = TRUE;
      $issues = array();
      foreach ($issues_array as $issue_array) {
        $term = taxonomy_term_load($issue_array['tid']);
        if (!empty($term)) {
          array_push($issues, l($term->name, 'petitions/all/0/2/' . intval($term->tid)));
        }
      }
      $issues = implode(", ", $issues);
    }

    // Petition status.
    $petition_status = $node->field_petition_status[$lang][0]['value'];

    // Set a flag for archived petitions
    if ($petition_status == WH_PETITION_STATUS_CLOSED) {
      $archived = TRUE;
    }
    // Petitions that have been reviewed and have a response attached ( should always be there together, but check just in case )
    elseif ($petition_status == WH_PETITION_STATUS_REVIEWED) {
      if ($node->field_response_status[$lang][0]['value'] == WH_PETITION_RESPONSE_STATUS_ANSWERED) {
        $responded = TRUE;

        // Get response details.  node_load might be a bit much in this case, but for now we'll stick with it.
        $response = node_load($node->field_response_id[$lang][0]['target_id']);
        if (!empty($response) && $response->status > 0) {
          $response_title = check_plain($response->title);
          $response_body = $response->body[$response->language][0]['safe_value'];

          $agency_name = '';
          if (!empty($response->field_agency_name[$response->language][0]['value'])) {
            $agency_name = $response->field_agency_name[$response->language][0]['value'];
          }
          $agency_seal = '';
          if (!empty($response->field_agency_seal[$response->language][0]['uri'])) {
            $image_vars = array(
             'style_name' => 'agency_seal',
             'path' => $response->field_agency_seal[$response->language][0]['uri'],
             'alt' => (!empty($response->field_agency_seal[$response->language][0]['alt'])) ? check_plain($response->field_agency_seal[$response->language][0]['alt']) : '',
             'title' => (!empty($response->field_agency_seal[$response->language][0]['title'])) ? check_plain($response->field_agency_seal[$response->language][0]['title']) : '',
             'attributes' => array('class' => array('graphic')),
             'getsize' => TRUE,
            );
            $agency_seal = theme('image_style', $image_vars);
          }

          // Retrieve the appropiate audio/video field info for the response.
          if (!empty($response->field_response_media[$response->language][0])) {
            $media_tid = $response->field_response_media[$response->language][0]['tid'];
            $media = taxonomy_term_load($media_tid);
            $media_name = $media->name;

            switch ($media_name) {
              case 'Audio':
                if (!empty($response->field_audio_embed[$response->language][0])) {
                  $response_audio = check_plain($response->field_audio_embed[$response->language][0]['value']);
                }
                break;

              case 'Video':
                if (!empty($response->field_video_embed[$response->language][0])) {
                  $response_video = check_plain($response->field_video_embed[$response->language][0]['value']);
                }
                break;
            }
          }
        }
      }
    }
    // Petitions that have been flagged for review.
    elseif ($petition_status == WH_PETITION_STATUS_FLAGGED) {
      $flagged = TRUE;
    }

    // Admin Functionality
    $admin = FALSE;
    $admin_link = '';
    $reached_ready = '';
    if (user_access('administer petitions')) {
      $admin = TRUE;
      if (!empty($node->field_timestamp_reached_ready[$lang][0]['value'])) {
        $reached_ready = date('M d, Y', $node->field_timestamp_reached_ready[$lang][0]['value']);
      }

      if (petitions_data_mysql_writes_are_enabled() && function_exists("petitionevents_get_administer_link")) {
        $admin_link = petitionevents_get_administer_link();
      }
      elseif ($legacy_id) {
        $admin_link = l(t('Administer This Petition'), 'admin/petitions/' . check_plain($legacy_id), array('attributes' => array('classes' => array('no-follow'))));
      }
    }

    $flagged_text = '';
    $flagged_text_owner = '';
    if ($flagged) {
      $flagged_text = variable_get('wh_petitions_flagged_page_text', '');
      if ($node->uid == $user->uid) {
        $flagged_text_owner = variable_get('wh_petitions_flagged_page_creator_text', '');
      }
    }
    $petition_goals_link = variable_get('wh_petitions_learn_more_link', '');

    // See if this user already signed the petition
    $already_signed = FALSE;
    if (!empty($user->uid)) {
      $signatures = SignaturesSelectQueryFactory::create()
      ->setPetitionId($petition_id)
      ->setUid($user->uid)
      ->execute()
      ->getResult();
      if (!empty($signatures[0]['id'])) {
        $already_signed = TRUE;
      }
    }
    // Show the signature form for petitions that haven't been signed by this user and are available to be signed.
    $comment_form = '';
    $why_text = '';
    // Do not display a form if user already signed it.
    if ($already_signed) {
      $signature_form = '';
    }
    // Petition hasn't been signed.
    else {
      // Check if login is required or if simplified login is on.
      switch ($login_required) {
        case TRUE:
          // Prepare a button that will appear grayed out if the user is not logged in and the login/registration is required to sign.
          if (!$logged_in) {
            $signature_form = l('Sign This Petition', 'user/login', array('attributes' => array('id' => 'button-sign-this-petition')));
            $why_text = variable_get('wh_petitions_tooltip_why', '');
          }
          // Display a direct sign button if user is authenticated and login is required to sign the petition.
          elseif (in_array($petition_status, array(WH_PETITION_STATUS_PRIVATE, WH_PETITION_STATUS_PUBLIC, WH_PETITION_STATUS_UNDER_REVIEW))) {
            module_load_include('inc', 'wh_petitions', 'wh_petitions.form');
            $signature_form = drupal_get_form('wh_petitions_sign_petition_form', $petition_id);
            $signature_form = drupal_render($signature_form);
            $comment_form = drupal_get_form('wh_petitions_comment_petition_form', $petition_id);
            $comment_form = drupal_render($comment_form);
          }
          else {
            $signature_form = '';
          }
          break;
        case FALSE:
        default:
          // Hide form in favor of displaying a side rail block version.
          $signature_form = '';
          break;
      }
    }

    // Set the 'Report as Inappropriate' link if it should appear.  Should appear on public/private/under review
    $reported_link = variable_get('wh_petitions_reported_as_inappropriate_link', '');
    $inappropriate_form = '';
    $has_reported = FALSE;
    $abuse_flag = array('target_id' => $user->uid);
    $is_flagged = (!empty($node->field_abuse_flags[$lang])) && is_array($node->field_abuse_flags[$lang]);
    if (in_array($petition_status, array(WH_PETITION_STATUS_DRAFT, WH_PETITION_STATUS_CLOSED, WH_PETITION_STATUS_REVIEWED, WH_PETITION_STATUS_FLAGGED)) || empty($user->uid)) {
      $inappropriate_link = FALSE;
    }
    elseif ($is_flagged && in_array($abuse_flag, $node->field_abuse_flags[$lang])) {
      $inappropriate_link = FALSE;
      $has_reported = TRUE;
    }
    else {
      $inappropriate_link = TRUE;
      module_load_include('inc', 'wh_petitions', 'wh_petitions.form');
      $inappropriate_form = drupal_get_form('wh_petitions_report_inappropriate_form', $petition_id);
      $inappropriate_form = drupal_render($inappropriate_form);
    }

    // Whether to include the share functionality.
    $has_share_bar = TRUE;
    if (in_array($petition_status, array(WH_PETITION_STATUS_DRAFT, WH_PETITION_STATUS_REVIEWED, WH_PETITION_STATUS_FLAGGED))) {
      $has_share_bar = FALSE;
    }

    // Get the signatures to display
    $has_more = TRUE;
    $signature_html = '';
    $page = 1;
    $sigs_per_page = 20;
    $last_id = '';
    if (!empty($_GET['page'])) {
      $get_page = preg_replace('/[^0-9]/', '', $_GET['page']);
      if (is_int((int) $get_page)) {
        $page = intval($get_page);
        $sigs_per_page = 19;
        $last_id = preg_replace('/[^a-zA-Z0-9]/', '', $_GET['last']);
      }
    }

    module_load_include('inc', 'wh_petitions', 'wh_petitions.pages');

    $signatures = wh_petitions_get_signatures($petition_id, $node->uid, $page, $has_more, FALSE, $signature_total, $last_id);
    $last_id = '';
    $previously_found_creator = '0';
    if (!empty($signatures)) {
      $last_id = $signatures[(sizeof($signatures) -1)]['id'];
      $previously_found_creator = $signatures[(sizeof($signatures) -1)]['previously_found_creator'];
    }

    $signature_html = theme('wh_petitions_display_signatures', array(
      'signatures' => $signatures,
      'petition_id' => check_plain($petition_id),
      'page' => $page,
      'has_more' => $has_more,
      'sigs_per_page' => $sigs_per_page,
      'last_id' => $last_id,
      'nice_url' => $path,
      'previously_found_creator' => $previously_found_creator,
    ));

    $return_destination = drupal_get_destination();
    $return_destination = preg_replace('/\?.*/', '', $return_destination);
    $vars['petition_title'] = check_plain($petition_title);
    $vars['body'] = wh_petitions_format_description($body);
    $vars['nid'] = $nid;
    $vars['petition_id'] = $petition_id;
    $vars['legacy_id'] = $legacy_id;
    $vars['short_url'] = $short_url;
    $vars['issues'] = $issues;
    $vars['date_published'] = $date_published;
    $vars['flagged'] = $flagged;
    $vars['responded'] = $responded;
    $vars['archived'] = $archived;
    $vars['flagged_text'] = $flagged_text;
    $vars['flagged_text_owner'] = $flagged_text_owner;
    $vars['admin'] = $admin;
    $vars['admin_link'] = $admin_link;
    $vars['reached_ready'] = check_plain($reached_ready);
    $vars['end_date'] = check_plain($end_date);
    $vars['total_needed'] = wh_petitions_format_number($total_needed);
    $vars['signatures_needed'] = wh_petitions_format_number($signatures_needed);
    $vars['signature_count'] = wh_petitions_format_number(count($signatures));
    $vars['signature_total'] = wh_petitions_format_number($signature_total);
    $vars['already_signed'] = $already_signed;
    $vars['signature_form'] = $signature_form;
    $vars['comment_form'] = $comment_form;
    $vars['why_text'] = $why_text;
    $vars['inappropriate_form'] = $inappropriate_form;
    $vars['inappropriate_link'] = $inappropriate_link;
    $vars['has_reported'] = $has_reported;
    $vars['reported_link'] = $reported_link;
    $vars['petition_goals_link'] = $petition_goals_link;
    $vars['has_share_bar'] = $has_share_bar;
    $vars['login_required'] = $login_required;
    $vars['logged_in'] = $logged_in;
    $vars['response_title'] = $response_title;
    $vars['response_body'] = $response_body;
    $vars['response_audio'] = $response_audio;
    $vars['response_video'] = $response_video;
    $vars['agency_name'] = $agency_name;
    $vars['agency_seal'] = $agency_seal;
    $vars['twitter_link'] = wh_petition_tool_twitter_link(check_plain($petition_id), check_plain($petition_title), 'petition', '', $short_url, $path);
    $vars['facebook_link'] = wh_petition_tool_facebook_link(check_plain($petition_id), check_plain($petition_title), 'petition', '', $path);
    $vars['path_to_petitions44'] = $base_url . '/' . drupal_get_path('theme', 'petitions44');
    $vars['return_destination'] = $return_destination;
    $vars['signature_html'] = $signature_html;
  }
}

/**
 * Implements hook_node_view()
 */
function wh_petitions_node_view($node, $view_mode, $langcode) {
  if ($node->type == 'petition') {
    $context = context_load('petition');
    context_set('context', 'petition', $context);
  }
}

/**
 * Implements hook_block_info().
 */
function wh_petitions_block_info() {
  $blocks['wh_petitions_by_numbers'] = array(
    'info' => 'By The Numbers',
    'cache' => DRUPAL_CACHE_GLOBAL,
  );
  $blocks['wh_petitions_create_account'] = array(
    'info' => 'Create a WH Account',
    'cache' => DRUPAL_CACHE_GLOBAL,
  );
  $blocks['wh_petitions_create_petition'] = array(
    'info' => 'Create Petition Button',
    'cache' => DRUPAL_CACHE_GLOBAL,
  );
  $blocks['wh_petitions_back_to_top'] = array(
    'info' => 'Back to top',
    'cache' => DRUPAL_CACHE_GLOBAL,
  );
  $blocks['wh_petitions_email_signup'] = array(
    'info' => 'Email Signup',
    'cache' => DRUPAL_CACHE_GLOBAL,
  );
  $blocks['wh_petitions_featured_petition'] = array(
    'info' => 'Helpful Hints',
    'cache' => DRUPAL_CACHE_PER_PAGE,
  );
  $blocks['wh_petitions_helpful_hints'] = array(
    'info' => 'Helpful Hints',
    'cache' => DRUPAL_CACHE_PER_PAGE,
  );
  $blocks['wh_petitions_history'] = array(
    'info' => 'History of Petitions',
    'cache' => DRUPAL_CACHE_GLOBAL,
  );
  $blocks['wh_petitions_recent_petitions'] = array(
    'info' => t('Recent Petitions'),
    'cache' => DRUPAL_CACHE_GLOBAL,
  );
  $blocks['wh_petitions_similar_petitions'] = array(
    'info' => t('Similar Petitions'),
    'cache' => DRUPAL_CACHE_PER_PAGE,
  );
  $blocks['wh_petitions_trending_petitions'] = array(
    'info' => t('Trending Petitions'),
    'cache' => DRUPAL_CACHE_GLOBAL,
  );

  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function wh_petitions_block_view($delta) {
  $block = array();

  switch ($delta) {
    // By The Numbers.
    case 'wh_petitions_by_numbers':
      $block['subject'] = t('By The Numbers');
      $block['content'] = wh_petitions_by_the_numbers();
      break;

    // Create A WH Account.
    case 'wh_petitions_create_account':
      $block['subject'] = t('Create a WH Account');
      $block['content'] = variable_get('wh_petitions_create_account_block_text', '');
      break;

    // Create A Petition.
    case 'wh_petitions_create_petition':
      $block['subject'] = '';
      $block['content'] = l(t('Create A Petition'), 'petition/create', array('attributes' => array('class' => array('button'), 'id' => 'button-create-a-petition')));
      break;

    case 'wh_petitions_back_to_top':
      $block['subject'] = '';
      $block['content'] = '<span class="button hide" id="button-back-to-top">Back to top</span>';
      break;

    // Email Updates.
    case 'wh_petitions_email_signup':
      $block['subject'] = t('Sign Up For Email Updates');
      $block['content'] = variable_get('wh_petitions_email_updates_block_text', t('Sign Up for Updates from President Obama and Other Senior Officials.'));
      break;

    // History of Petitions.
    case 'wh_petitions_history':
      $block['subject'] = t('History of Petitions');
      $block['content'] = variable_get('wh_petitions_history_block_text', '');
      break;

    // Helpful Hints.
    case 'wh_petitions_helpful_hints':
      $block['subject'] = t('Helpful Hints');

      global $user;
      $content = '';
      if (arg(0) == 'petition' && arg(1) == 'create') {
        $content = variable_get('wh_petitions_hints_create_petition', '');
      }
      elseif (arg(0) == 'petitions') {
        $content = variable_get('wh_petitions_hints_open_petitions', '');
      }
      elseif (arg(0) == 'petition' && arg(1) == 'detail') {
        $content = variable_get('wh_petitions_hints_petition_detail', '');
      }
      elseif (arg(0) == 'responses') {
        $content = variable_get('wh_petitions_hints_responses', '');
      }
      elseif (arg(0) == 'response' && arg(1) == 'detail') {
        $content = variable_get('wh_petitions_hints_response_detail', '');
      }
      elseif (arg(0) == 'dashboard' && !empty($user->uid)) {
        $content = variable_get('wh_petitions_hints_dashboard', '');
      }
      else {
        $content = variable_get('wh_petitions_hints_misc', '');
      }

      $block['content'] = $content;
      break;

    // Recent Petitions.
    case 'wh_petitions_recent_petitions':
      $block['subject'] = t('Recent Petitions');

      $petitions_query = PetitionsSelectQueryFactory::create();
      $result = $petitions_query->setIsOpen(TRUE)
        ->setOrderBy(PetitionsSelectQuery::SELECT_QUERY_ORDER_BY_FIELD_DATE_REACHED_PUBLIC, PetitionsSelectQuery::SELECT_QUERY_ORDER_BY_DESC)
        ->setLimit(3)
        ->execute()
        ->getResult();

      $html = '';
      if (!empty($result)) {
        $html = '<ul>';
        foreach ($result as $res) {
          $html .= '<li>' . l($res['title'], $res['url']) . '</li>';
        }
        $html .= '</ul>';
      }
      $block['content'] = $html;
      break;

    // Similar Petitions.
    case 'wh_petitions_similar_petitions':
      $block['subject'] = t('Similar Petitions');

      // Only should display content on a petition detail page.
      if ((arg(0) == 'petition')) {
        if (petitions_data_mongo_reads_are_enabled()) {
          $conn = wh_petitions_mongo_petition_connection();
          $petition_id = wh_petitions_get_petition_id($conn);
          $block['content'] = wh_petitions_similar_petitions($conn, $petition_id);
        }
        else {
          $petition_id = wh_petitions_get_petition_id_by_url('petition/' . arg(1));
          $conn = NULL;
          $block['content'] = wh_petitions_similar_petitions($conn, $petition_id);
        }
      }
      else {
        $block['content'] = '';
      }
      break;

    // Trending Petitions.
    case 'wh_petitions_trending_petitions':
      module_load_include('inc', 'wh_petitions', 'wh_petitions.pages');
      $block['subject'] = t('Trending Petitions');
      $html = '';
      $total = 0;

      if (petitions_data_mongo_reads_are_enabled()) {
        // Get 3 most trending petitions.
        $conn = wh_petitions_mongo_petition_connection();
      }
      else {
        $conn = NULL;
      }

      $result = wh_petitions_trending_results($conn, 0, 3, $total);

      $html = '<ul>';
      foreach ($result as $res) {
        $html .= '<li>' . l($res['title'], $res['nice_url']) . '</li>';
      }
      $html .= '</ul>';

      $block['content'] = $html;
      break;
  }

  return $block;
}

/**
 * Implements hook_block_view_alter().
 */
function wh_petitions_block_view_alter(&$data, $block) {
  switch ($block->delta) {
    // Control the petitionssignatureform_form block visibility.
    case 'petitionssignatureform_form':
      $login_required = (variable_get('petitions_signing_method', WH_PETITIONS_SIGNING_METHOD_REGISTRATION_REQUIRED) == WH_PETITIONS_SIGNING_METHOD_REGISTRATION_REQUIRED) ? TRUE : FALSE;

      if ($login_required) {
        unset($data['content']);
      }
      break;
  }
}

/**
 * Implements hook_info().
 */
function wh_petitions_hook_info() {
  $hooks = array();
  $hooks['wh_petitions_signature_save'] = array(
    'group' => 'petitions',
  );
  return $hooks;
}

/**
 * List un-notified compliant petitions.
 *
 * Pulls a list of petitions with more signatures than the compliance review
 * threshold and which have not been sent compliance review notifications.
 */
function wh_petitions_compliance_review_threshold_check($threshold, $compliance_reviewer_emails) {
  if ($compliance_reviewer_emails && (int) $threshold) {
    if (petitions_data_mongo_reads_are_enabled()) {
      // The to-be-deprecated mongo version of this function.
      wh_petitions_mongo2mysql_compliance_review_threshold_check($threshold, $compliance_reviewer_emails);
    }
    else {
      // @mongo2mysql: Relatively simple query, written while mysql
      // api is still in development. Would be better to utilize
      // the PetitionSelectQuery class when it's ready.
      $petition_status = array(
        WH_PETITION_STATUS_DRAFT,
        WH_PETITION_STATUS_PRIVATE,
        WH_PETITION_STATUS_PUBLIC,
      );

      $sub_query = db_or();
      $sub_query->isNull('review_threshold_mail_sent.field_review_threshold_mail_sent_value');
      $sub_query->condition('review_threshold_mail_sent.field_review_threshold_mail_sent_value', 0, '=');

      $query = db_select('node', 'n');
      $query->leftJoin('field_data_field_petition_signature_count', 'petition_signature_count', 'petition_signature_count.entity_id = n.nid');
      $query->leftJoin('field_data_field_review_threshold_mail_sent', 'review_threshold_mail_sent', 'review_threshold_mail_sent.entity_id = n.nid');
      $query->leftJoin('field_data_field_petition_status', 'petition_status', 'petition_status.entity_id = n.nid');

      $query->addField('n', 'nid', 'nid');
      $query->addField('petition_signature_count', 'field_petition_signature_count_value', 'signature_count');

      $query->condition('petition_signature_count.field_petition_signature_count_value', $threshold, '>=');
      $query->condition($sub_query);
      $query->condition('petition_status.field_petition_status_value', $petition_status, 'IN');

      $notification_list = $query->execute()->fetchAllAssoc('nid');

      foreach ($notification_list as $notification_nid => $notification) {
        $petition = node_load($notification_nid);

        $message = drupal_mail('wh_petitions', 'review_threshold_passed', $compliance_reviewer_emails, language_default(),
          array(
            'petition' => (array) $petition,
          )
        );

        $legacy_id = check_plain($petition->field_legacy_id[$petition->language][0]['value']);

        // Set the Review Threshold Mail Sent field on the petition
        // node so we know the mail has been sent.
        $review_threshold_mail_sent = time();
        $petition->field_review_threshold_mail_sent[$petition->language][0]['value'] = $review_threshold_mail_sent;
        node_save($petition);

        // Mongo2mysql: This condition checks if we are still writing to mongo.
        $update_mongo_petition = ((petitions_data_mongo_writes_are_enabled()) && (!empty($legacy_id)));
        if ($update_mongo_petition) {
          $petition_connection = wh_petitions_mongo_petition_connection();
          $petition_mongo = wh_petitions_load_slim_petition($petition_connection, $legacy_id, array('body'));

          $petition_connection->update(
            array('_id' => $petition_mongo['_id']),
            array('$set' => array('review_threshold_mail_sent' => (int) $review_threshold_mail_sent))
          );
        }

      }
      watchdog('wh_petitions', 'Petition (@id) Review Threshold Notification Sent.', array('@id' => $notification_nid));
    }
  }
}

/**
 * By The Numbers block body.
 */
function wh_petitions_by_the_numbers() {
  $numbers = array();
  if (petitions_data_mongo_reads_are_enabled()) {
    $conn = wh_petitions_mongo_petition_connection();

    // Total Petitions that are open.
    if (variable_get('wh_petitions_numbers_open_petitions', FALSE)) {
      $query = array(
        'petition_status' => array(
          '$in' => array((int) WH_PETITION_STATUS_PUBLIC, (int) WH_PETITION_STATUS_UNDER_REVIEW),
        ),
        'hidden' => 0,
      );
      $total = $conn->find($query)->count();
      array_push($numbers, array('key' => t('Open Petitions'), 'value' => check_plain(wh_petitions_format_number($total))));
    }
    // Total Responses that are published.
    if (variable_get('wh_petitions_numbers_responses', FALSE)) {
      $query = db_select('node', 'n', array('target' => 'slave'));
      $query->fields('n', array('nid'))
        ->condition('n.type', 'wh_response')
        ->condition('n.status', 0, '<>');
      $total = $query->countQuery()->execute()->fetchField();
      array_push($numbers, array('key' => t('Total Responses'), 'value' => check_plain(wh_petitions_format_number($total))));
    }
    // Signatures in Past 24 Hours.
    if (variable_get('wh_petitions_numbers_signatures_24', FALSE)) {
      $sig_conn = wh_petitions_mongo_petition_signatures_connection();
      $timestamp = strtotime("-1 day");
      $query = array(
        'timestamp' => array('$gt' => (int) $timestamp),
      );
      $total = $sig_conn->find($query)->count();
      array_push($numbers, array('key' => t('Signatures in Past 24 Hours'), 'value' => check_plain(wh_petitions_format_number($total))));
    }
  }
  else {
    // Total Petitions that are open.
    if (variable_get('wh_petitions_numbers_open_petitions', FALSE)) {

      $query = db_select('node', 'n');
      $query->leftJoin('field_data_field_petition_status', 'ps', 'ps.entity_id = n.nid');
      $query->addExpression('count(n.nid)', 'total');
      $query->condition('n.type', 'petition', '=');
      $query->condition('ps.field_petition_status_value', array((int) WH_PETITION_STATUS_PUBLIC, (int) WH_PETITION_STATUS_UNDER_REVIEW), 'IN');

      $total = $query->countQuery()->execute()->fetchField();

      array_push($numbers, array('key' => t('Open Petitions'), 'value' => check_plain(wh_petitions_format_number($total))));
    }
    // Total Responses that are published.
    if (variable_get('wh_petitions_numbers_responses', FALSE)) {

      $query = db_select('node', 'n');
      $query->fields('n', array('nid'));
      $query->condition('n.type', 'wh_response');
      $query->condition('n.status', 0, '<>');

      $total = $query->countQuery()->execute()->fetchField();

      array_push($numbers, array('key' => t('Total Responses'), 'value' => check_plain(wh_petitions_format_number($total))));
    }
    // Signatures in Past 24 Hours.
    if (variable_get('wh_petitions_numbers_signatures_24', FALSE)) {

      $query = db_select('signature_mail', 'sm');
      $query->addField('sm', 'id');
      $query->addfield('sm', 'timestamp');
      $query->condition('sm.timestamp', strtotime("-1 day"), '>');

      $total = $query->countQuery()->execute()->fetchField();

      array_push($numbers, array('key' => t('Signatures in Past 24 Hours'), 'value' => check_plain(wh_petitions_format_number($total))));
    }
  }
  return theme('wh_petitions_by_the_numbers', array('numbers' => $numbers));
}

/**
 * Similar Petitions block body.
 */
function wh_petitions_similar_petitions(&$conn, $petition_id) {

  $html = '';

  if (petitions_data_mongo_reads_are_enabled()) {
    $petition = wh_petitions_load_slim_petition($conn, $petition_id, array('issues', 'title_keywords'));
    if (empty($petition)) {
      return '';
    }

    // Get the issues into an array of keys.
    $issues = array();
    foreach ($petition['issues'] as $key => $val) {
      if ($val > 0) {
        array_push($issues, intval($val));
      }
    }

    // Removed common words from the string of title keywords.
    $title_keywords = $petition['title_keywords'];
    $title_terms = array();

    $search_terms = array(
      "and",
      "in",
      "this",
      "or",
      "a",
      "the",
      "an",
      "as",
      "at",
      "but",
      "by",
      "before",
      "for",
      "from",
      "is",
      "like",
      "of",
      "on",
      "onto",
      "than",
      "this",
      "that",
      "to",
      "with",
    );
    foreach ($title_keywords as $term) {
      if (!in_array($term, $search_terms)) {
        array_push($title_terms, $term);
      }
    }

    // Retrive the top 3 results sorted by signature
    // count DESC that match all the issues and at least
    // one of the title words and are not the current petition.
    $similar = '';
    $count = 0;
    $query = array(
      'petition_status' => array(
        '$in' => array((int) WH_PETITION_STATUS_PUBLIC, (int) WH_PETITION_STATUS_UNDER_REVIEW),
      ),
      'hidden' => 0,
      'issues' => array('$in' => $issues),
      'title_keywords' => array('$in' => $title_terms),
      '_id' => array('$ne' => $petition['_id']),
    );
    $result = $conn->find($query, array('title', 'nice_url'))->sort(array('signature_count' => -1))->limit(3);

    $html = '';
    foreach ($result as $res) {
      if (empty($html)) {
        $html = '<ul>';
      }
      $html .= '<li>' . l($res['title'], $res['nice_url']) . '</li>';
    }
    if (!empty($html)) {
      $html .= '</ul>';
    }
  }
  else {

    if (!is_numeric($petition_id)) {
      $petition_id = petition_get_nid($petition_id);
    }
    $petition = node_load($petition_id);
    if (empty($petition)) {
      return '';
    }

    // Get the issues into an array of keys.
    $issues = array();
    foreach ($petition->field_petition_issues[$petition->language] as $key => $val) {
      if ($val['tid'] > 0) {
        array_push($issues, intval($val['tid']));
      }
    }

    // Removed common words from the string of title keywords.
    $title_keywords = $petition->title;
    $title_terms = array();

    $search_terms = array(
      "and",
      "in",
      "this",
      "or",
      "a",
      "the",
      "an",
      "as",
      "at",
      "but",
      "by",
      "before",
      "for",
      "from",
      "is",
      "like",
      "of",
      "on",
      "onto",
      "than",
      "this",
      "that",
      "to",
      "with",
    );
    foreach ($title_keywords as $term) {
      if (!in_array($term, $search_terms)) {
        array_push($title_terms, $term);
      }
    }

    // Retrive the top 3 results sorted by signature
    // count DESC that match all the issues and at least
    // one of the title words and are not the current petition.
    $similar = '';
    $count = 0;

    $query = db_select('node', 'n');
    $query->leftJoin('field_data_field_petition_status', 'ps', 'ps.entity_id = n.nid');
    $query->leftJoin('field_data_field_petition_issues', 'pi', 'pi.entity_id = n.nid');
    $query->leftJoin('url_alias', 'ua', 'substring(ua.source, 6) = n.nid');
    $query->leftJoin('field_data_field_petition_signature_count', 'sc', 'cs.entity_id = n.nid');

    $query->addField('n', 'nid');
    $query->addField('n', 'title');
    $query->addField('ua', 'alias', 'nice_url');

    $query->condition('n.type', 'petition', '=');
    $query->condition('ps.field_petition_status_value', array((int) WH_PETITION_STATUS_PUBLIC, (int) WH_PETITION_STATUS_UNDER_REVIEW), 'IN');
    $query->condition('pi.field_issues_tid', $issues, 'IN');
    $query->condition('n.title', $title_keywords, 'IN');

    $query->orderBy('field_data_field_petition_signature_count.field_petition_signature_count_value', 'DESC');
    $query->range(0, 3);

    $result = $query->execute()->fetchAllAssoc('nid');

    $html = '';
    foreach ($result as $res) {
      if (empty($html)) {
        $html = '<ul>';
      }
      $html .= '<li>' . l($res['title'], $res['nice_url']) . '</li>';
    }
    if (!empty($html)) {
      $html .= '</ul>';
    }
  }

  return $html;
}

/**
 * Implements hook_cron().
 *
 * Include the function to close any open petitions that
 * have exceeded the limit for amount of days to be open.
 * This function also updates the trending petitions and the counts
 * of how many petitions/responses are related to each issue term.
 */
function wh_petitions_cron() {
  module_load_include('inc', 'wh_petitions', 'wh_petitions.cron');
  wh_petitions_close_petitions();

  $email = variable_get('wh_petitions_compliance_reviewer_emails', FALSE);
  $threshold = (int) variable_get('wh_petitions_compliance_review_threshold', FALSE);
  wh_petitions_compliance_review_threshold_check($threshold, $email);
}

/**
 * Helper function to format a number correctly.
 *
 * Helper function to format a number correctly.
 * (no decimals, commas for thousands-separators)
 */
function wh_petitions_format_number($number) {
  return number_format(intval($number), 0, '.', ',');
}

/**
 * Format description for petition detail.
 *
 * Helper function to format a description on the petition
 * detail and preview pages ( step 4 - create a petition )
 */
function wh_petitions_format_description($description) {
  if (!empty($description)) {
    // Consolidate newlines.
    $description = preg_replace('/[\r\n]+/', "\n", $description);
    $arr = explode("\n", $description);

    $new_description = '';
    foreach ($arr as $line) {
      $new_description .= '<p>' . check_plain(trim($line)) . '</p>';
    }
    $description = $new_description;
  }

  return $description;
}

/**
 * Emails the creator of a petition when their petition is published.
 */
function wh_petitions_email_published($petition_id, $uid) {
  if (!empty($uid)) {
    $user_load = user_load($uid);

    if (!empty($user_load)) {
      $email = $user_load->mail;
      $params = array('petition_id' => $petition_id);
      $from = variable_get('wh_petitions_email_address', '');
      drupal_mail('wh_petitions', 'published', $email, language_default(), $params, $from);
    }
  }
}

/**
 * Email user when their petition is under review.
 *
 * Emails the creator of a petition when their petition
 * becomes under review ( enough signatures to receive a response )
 */
function wh_petitions_email_ready_response($petition_id, $uid) {
  if (!empty($uid)) {
    $user_load = user_load($uid);

    if (!empty($user_load)) {
      $email = $user_load->mail;
      $params = array();
      $from = variable_get('wh_petitions_email_address', '');
    }
  }
}

/**
 * Email user when their petitions have been responded to.
 *
 * Emails the creator of a petition when their petition
 * receives a response. Currently not active.
 */
function wh_petitions_email_receive_response($petition_id, $uid) {
  if (!empty($uid)) {
    $user_load = user_load($uid);

    if (!empty($user_load)) {
      $email = $user_load->mail;
      $params = array();
      $from = variable_get('wh_petitions_email_address', '');
    }
  }
}

/**
 * Implements hook_mail().
 *
 * Implements the email messages for when a petition is
 * published, is ready for a response and receives a response.
 */
function wh_petitions_mail($key, &$message, $params) {
  global $base_url;
  $options['language'] = $message['language'];
  $legacy_id = "";

  switch ($key) {
    case 'published':
      $langcode = $message['language']->language;
      $message['subject'] = variable_get('wh_petitions_email_published_subject', '');
      $message['body'][] = variable_get('wh_petitions_email_published_text', '');
      $legacy_id = $params['petition_id'];

      $petition = PetitionsController::loadObject($legacy_id);

      if (!empty($petition)) {

        // In case the short URL isn't available, use the absolute form of the
        // nice URL to use in emails, so that there's at least *something* to
        // click on.
        $short_url = ($petition->getShortUrl() != '') ? $petition->getShortUrl() : $petition->getNiceUrl();

        $end_date = strtotime('+' . $petition->getReviewTimeframe() . ' days', $petition->getPublished());
        $end_date = date("F d, Y", $end_date);
        $message['subject'] = str_replace('!shorturl', $short_url, $message['subject']);
        $message['subject'] = str_replace('!petition_title', $petition->getTitle(), $message['subject']);
        $message['body'][0] = str_replace('!petition_description', check_plain($petition->getBody()), $message['body'][0]);
        $message['body'][0] = str_replace('!shorturl', check_plain($short_url), $message['body'][0]);
        $message['body'][0] = str_replace('!petition_title', check_plain($petition->getTitle()), $message['body'][0]);
        $message['body'][0] = str_replace('!signatures_needed', wh_petitions_format_number($petition->getSignaturesNeeded()), $message['body'][0]);
        $message['body'][0] = str_replace('!public_signatures', wh_petitions_format_number($petition->getSignaturePublicThreshold()), $message['body'][0]);
        $message['body'][0] = str_replace('!date_needed', $end_date, $message['body'][0]);
        $message['body'][0] = str_replace('!day_timeframe', wh_petitions_format_number($petition->getReviewTimeframe()), $message['body'][0]);
      }
      else {
        unset($message);
      }

      break;

    case 'review_threshold_passed':
      $langcode = $message['language']->language;
      $message['subject'] = variable_get('wh_petitions_review_threshold_passed_subject', '');
      $message['body'][] = variable_get('wh_petitions_review_threshold_passed_text', '');

      $petition  = (array) $params['petition'];
      if (!empty($petition)) {
        if (petitions_data_mongo_reads_are_enabled()) {
          // This section should be removed as part of mongo2mysql cleanup.

          $legacy_id = check_plain($petition['_id']);

          if (function_exists('petitionevents_mail_additions')) {
            $context = array();
            $context["petition_title"] = $petition['title'];
            $context["petition_uid"] = $petition['_uid'];
            $context["legacy_id"] = $legacy_id;

            // Mongo2MySql code that can eventually be removed.
            $is_mysql_enabled = petitions_data_mysql_writes_are_enabled();

            if ($is_mysql_enabled) {
              $context["nid"] = petition_get_nid($legacy_id);
            }

            $message_body = $message['body'][0];
            petitionevents_mail_additions($message_body, $context);
            $message['body'][0] = $message_body;
          }

          $message['body'][0] = str_replace('!petition_id', check_plain($legacy_id), $message['body'][0]);
          $message['body'][0] = str_replace('!petition_edit_link', variable_get('petitions_edit_url', $base_url) . '/admin/petitions/' . check_plain($petition['_id']), $message['body'][0]);
          $message['body'][0] = str_replace('!petition_title', check_plain($petition['title']), $message['body'][0]);
          $message['body'][0] = str_replace('!petition_body', check_plain($petition['body']), $message['body'][0]);

          $link_path = "$base_url/admin/petitions/$legacy_id";
          $link = l($link_path, $link_path);
          $message['body'][0] = str_replace('!petition_remove_link', $link, $message['body'][0]);
        }
        else {
          // Data was read from MySQL, so we have a petition node.
          $nid = check_plain($petition['nid']);
          $legacy_id = (isset($petition['field_legacy_id'][$petition['language']][0]['value']) ? check_plain($petition['field_legacy_id'][$petition['language']][0]['value']) : '');

          if (function_exists('petitionevents_mail_additions')) {
            $context = array();
            $context["petition_title"] = $petition['title'];
            $context["petition_uid"] = $petition['uid'];
            $context["legacy_id"] = $legacy_id;
            $context["nid"] = $nid;

            $message_body = $message['body'][0];
            petitionevents_mail_additions($message_body, $context);
            $message['body'][0] = $message_body;
          }

          $message['body'][0] = str_replace('!petition_id', $nid, $message['body'][0]);
          $message['body'][0] = str_replace('!petition_edit_link', variable_get('petitions_edit_url', $base_url) . '/node/' . $nid . '/edit', $message['body'][0]);
          $message['body'][0] = str_replace('!petition_title', check_plain($petition['title']), $message['body'][0]);
          $message['body'][0] = str_replace('!petition_body', check_plain($petition['body'][$petition['language']][0]['value']), $message['body'][0]);

          // Replacement for petition_remove_link.
          $link_path = url('admin/moderation-tools', array(
            'query' => array('nid' => $nid),
            'absolute' => TRUE,
          ));
          $link = l($link_path, $link_path);
          $message['body'][0] = str_replace('!petition_remove_link', $link, $message['body'][0]);
        }
      }
      else {
        unset($message);
      }
      break;

    case 'ready_response':
      $legacy_id = $params['petition_id'];
      $langcode = $message['language']->language;
      $message['subject'] = variable_get('wh_petitions_email_ready_response_subject', '');
      $message['body'][] = variable_get('wh_petitions_email_ready_response_text', '');
      break;

    case 'receive_response':
      $legacy_id = $params['petition_id'];
      $langcode = $message['language']->language;
      $message['subject'] = variable_get('wh_petitions_email_receive_response_subject', '');
      $message['body'][] = variable_get('wh_petitions_email_receive_response_text', '');
      break;

    case 'status_change':
      $legacy_id = $params['petition']['_id'];
      if ($params['petition']['petition_status'] == 6) {
        $message['subject'] = t('Petition Removal');
        $message['body'][] = t('Petition @title (@id), has been removed by @remover',
          array(
            '@title' => $params['petition']['title'],
            '@id' => $params['petition']['_id'],
            '@remover' => $params['remover'],
          )
        );
        $message['body'][] = t("The creator's email is @mail",
          array(
            '@mail' => $params['creator_email'],
          )
        );
        break;

      }

      // We're only sending mail for removals, so don't do anything else.
      return FALSE;
  }

  $message['body'][0] = str_replace('!baseurl', check_plain($base_url), $message['body'][0]);
}

/**
 * Custom access callback for petition nodes.
 *
 * @param string $op
 *   Operation to be checked, one of view, update, delete, create
 * @param mixed $node
 *   Either the node to perform the operation on or the node type to create.
 * @param null $account
 *   User account to check permission for
 *
 * @return bool
 *   Return TRUE if user should have access, call node_access() if it
 *   isn't a a petition node or an operation we don't care about.
 */
function wh_petitions_petition_access($op, $node, $account = NULL) {
  if (is_object($node) && $node->type != 'petition') {
    return node_access($op, $node, $account);
  }

  if (empty($account)) {
    $account = $GLOBALS['user'];
  }

  $petition_status = is_object($node) ? $node->field_petition_status[$node->language][0]['value'] : NULL;

  switch ($op) {
    case 'view':
      // Allow super-admin to view petitions in any status, but only published for regular admins.
      if ($account->uid != 1) {
        if ($petition_status == WH_PETITION_STATUS_DRAFT) {
          return FALSE;
        }
      }
      break;

    case 'update':
    case 'delete':
      // Allow only user 1 to access these operations.
      return $account->uid == 1;
      break;

    case 'create':
      // Force everyone to use the /petition/create workflow.
      if ($node == 'petition') {
        return FALSE;
      }
    break;
  }

  // If nothing matched, fall through to the default access callback.
  return node_access($op, $node, $account);

}

/**
 * Custom user access callback function for wh_petitions module.
 *
 * @param string $string
 *   Permission string to check.
 * @param mixed $account
 *   Account object to check permission, defaults to NULL.
 *
 * @return bool
 *   Returns TRUE if user represented by $account has this permission.
 */
function _wh_petitions_user_access($string, $account = NULL) {

  if (!isset($account)) {
    $account = $GLOBALS['user'];
  }

  if ($account->uid == 1) {
    return TRUE;
  }
  // Sanity check to make sure this is the one permission we are interested in.
  if ($string == 'access devel information') {
    return FALSE;
  }

  // Return core user_access() on the odd chance we get here.
  return user_access($string, $account);
}

/**************** MONGO HELPER FUNCTIONS ******************/

/**
 * Creates a connection to the petitions collection.
 */
function wh_petitions_mongo_petition_connection() {
  try {
    $collection = mongodb_collection('petitions');
  }
  catch (Exception $e) {
    petitionslog_event('exception.wh_petitions.0ba11dd');
  }

  if (!petitions_data_mongo_reads_are_enabled()) {
    $backtrace = debug_backtrace();
    $calling_func = '';
    if (count($backtrace) > 1) {
      $calling_func = $backtrace[1]['function'];
    }
    watchdog('petition', 'wh_petitions_mongo_petition_connection() called. Calling Function: @calling_func', array(
      '@calling_func' => $calling_func,
    ), WATCHDOG_WARNING);
  }
  return $collection;
}

/**
 * Creates a connection to the archive_petitions collection.
 */
function wh_petitions_mongo_archive_petition_connection() {
  try {
    $collection = mongodb_collection('archive_petitions');
  }
  catch (Exception $e) {
    petitionslog_event('exception.wh_petitions.d918789');
  }

  if (!petitions_data_mongo_reads_are_enabled()) {
    $backtrace = debug_backtrace();
    $calling_func = '';
    if (count($backtrace) > 1) {
      $calling_func = $backtrace[1]['function'];
    }
    watchdog('petition', 'wh_petitions_mongo_archive_petition_connection() called. Calling Function: @calling_func', array(
      '@calling_func' => $calling_func,
    ), WATCHDOG_WARNING);
  }
  return $collection;
}

/**
 * Creates a connection to the petition signatures collection.
 */
function wh_petitions_mongo_petition_signatures_connection() {
  try {
    $collection = mongodb_collection('petition_signatures');
  }
  catch (Exception $e) {
    petitionslog_event('exception.wh_petitions.1616017');
  }

  if (!petitions_data_mongo_reads_are_enabled()) {
    $backtrace = debug_backtrace();
    $calling_func = '';
    if (count($backtrace) > 1) {
      $calling_func = $backtrace[1]['function'];
    }
    watchdog('petition', 'wh_petitions_mongo_petition_signatures_connection() called. Calling Function: @calling_func', array(
      '@calling_func' => $calling_func,
    ), WATCHDOG_WARNING);
  }
  return $collection;
}

/**
 * Saves a petition object to the petitions collection.
 *
 * Saves a petition object to the petitions collection.  It's more
 * efficient to use the $set operator unless there are major changes
 * or this is the first save.
 */
function wh_petitions_save_petition(&$collection, $petition) {
  if (!empty($petition) && !empty($collection)) {
    // Explicitly cast the uid as an integer.
    $petition['uid'] = (int) $petition['uid'];
    if ($petition['created'] == 0) {
      $petition['created'] = (int) time();
      petitionslog_event('petition.created');
    }
    $collection->save($petition);
    petitions_data_freshen_cached_petition($petition['_id']);

    return $petition['_id']->__toString();
  }
}

/**
 * Saves a signature object to the petition_signatures collection.
 *
 * @todo: Fix the return. For a new object, there is no _id value.
 */
function wh_petitions_save_signature($signature, $collection = '') {
  if (empty($collection)) {
    $collection = wh_petitions_mongo_petition_signatures_connection();
  }
  if (!empty($signature) && !empty($collection)) {
    $collection->save($signature);
    module_invoke_all('wh_petitions_signature_save', $signature, $collection);

    return $signature['_id']->__toString();
  }
}

/**
 * Deletes a petition object.
 *
 * Saves it to the archive_petition collection, removes from
 * petition collection.
 */
function wh_petitions_delete_petition(&$collection, $petition_id) {
  global $user;

  if (!empty($petition_id) && !empty($collection)) {
    $archive = wh_petitions_mongo_archive_petition_connection();
    $petition = array();
    $petition = wh_petitions_load_petition($collection, $petition_id);
    if (!empty($petition) && $user->uid == $petition['uid'] && $petition['petition_status'] == WH_PETITION_STATUS_DRAFT) {
      if ($archive->save($petition)) {
        // We successfully saved petition to archive, can now safely remove it.
        $collection->remove(array('_id' => new MongoId($petition_id)));

        return TRUE;
      }
    }
  }
  petitions_data_freshen_cached_petition($petition_id);

  return FALSE;
}

/**
 * Gets a petition id from a nice url.
 *
 * @param MongoClient $collection
 *   The resource of the MongoDB collection to query against.
 */
function wh_petitions_get_petition_id(&$collection) {
  if (!empty($collection)) {
    $petition_id = '';
    $petition = $collection->findOne(array('nice_url' => 'petition/' . arg(1)), array('title'));
    if (!empty($petition)) {
      return $petition['_id']->__toString();
    }
  }

  return '';
}

/**
 * Gets petition id from nice url.
 *
 * @param str $url
 *   The url to validate against.
 */
function wh_petitions_get_petition_id_by_url($url) {
  if (petitions_data_mongo_reads_are_enabled()) {
    return wh_petitions_get_petition_id(wh_petitions_mongo_petition_connection());
  }
  else {
    $query = db_select('node', 'n');
    $query->addJoin('url_alias', 'ua', 'substring(ua.source, 6) = n.nid');
    $query->addField('n', 'nid');
    $query->condition('ua.alias', db_like($url), 'LIKE');
    $result = $query->execute()->fetchAssoc();
    return $result['nid'];
  }

  return '';
}
/**
 * Check to see if signature exists already.
 *
 * @param string $petition_id
 *   The unique identifier of the petition.
 * @param int $uid
 *   A user ID.
 *
 * @return string|false
 *   Signature ID or FALSE if it doesn't exist yet.
 */
function wh_petitions_get_signature_id($petition_id, $uid) {
  $signature_id = FALSE;

  // Create connection.
  $sig_connection = wh_petitions_mongo_petition_signatures_connection();
  $sig_connection->setSlaveOkay(FALSE);

  // Determine if this user has already signed the petition.
  $query = array(
    'uid' => (int) $uid,
    'petition_id' => (string) $petition_id,
  );
  $result = $sig_connection->findOne($query);
  if (!empty($result)) {
    $signature_id = $result['_id']->__toString();
    // TODO make sure this ^^ works.
  }

  return $signature_id;
}


/**
 * Loads the minimum number of fields from the petition object.
 *
 * Loads the minimum number of fields from the petition object.
 * Use this instead of load_petition when we don't need access
 * to all ( or a majority ) of fields.
 *
 * @param MongoClient $collection
 *   The resource of the MongoDB collection to query against.
 * @param string $petition_id
 *   The unique identifier of the requested petition
 * @param array $extra_fields
 *   Fields that will be added into the query and returned.
 */
function wh_petitions_load_slim_petition(&$collection, $petition_id, $extra_fields = array()) {
  if (!empty($petition_id) && !empty($collection)) {
    // Convert to a Mongo ID if we got a string.
    if (!is_object($petition_id)) {
      $petition_id = new MongoId($petition_id);
    }

    $retrieve_fields = array('title', 'nice_url', 'short_url');
    $retrieve_fields = array_merge($retrieve_fields, $extra_fields);

    $petition = array();
    $petition = $collection->findOne(array('_id' => $petition_id), $retrieve_fields);
    return $petition;
  }

  return array();
}

/**
 * Loads a petition object and merges it with the default petition.
 */
function wh_petitions_load_petition(&$collection, $petition_id, $extra_fields = array()) {
  if (!empty($petition_id) && !empty($collection)) {
    // Convert to a Mongo ID if we got a string.
    if (!is_object($petition_id)) {
      $petition_id = new MongoId($petition_id);
    }

    $petition = array();
    $petition = $collection->findOne(array('_id' => $petition_id));

    if (!empty($petition)) {
      // Merge default object with one retrieved to pick up any new fields.
      $default = wh_petitions_default_petition();

      // Note: Fields with the same string keys from later arrays
      // override those from earlier arrays.
      $petition = array_merge($default, $petition);
      return $petition;
    }
  }

  return array();
}

/**
 * Gets a petition title.
 */
function wh_petitions_load_petition_title(&$collection, $petition_id) {
  if (!empty($petition_id) && !empty($collection)) {
    // Convert to a Mongo ID if we got a string.
    if (!is_object($petition_id)) {
      $petition_id = new MongoId($petition_id);
    }

    $petition = array();
    $petition = $collection->findOne(array('_id' => $petition_id), array('title'));
    return $petition['title'];
  }
}

/**
 * Generate keywords for fields.
 *
 * Generate keywords for title_keywords, body_keywords and
 * keywords ( public and private ) fields.
 *
 * @param string $string
 *   String to extract keywords from.
 * @param string $delimiter
 *   String to use as a delimiter for character analysis.
 *
 * @return array
 *   An indexed array of keywords.
 */
function wh_petitions_generate_keywords($string, $delimiter = ' ') {
  $words = array();

  if (!empty($string)) {
    $arr = explode($delimiter, $string);
    foreach ($arr as $word) {
      // Strip all nonalphanumeric, whitespace, etc.
      if ($delimiter != ' ') {
        $word = trim(preg_replace('/[^A-Za-z0-9\s]/', '', $word));
      }
      else {
        $word = preg_replace('/[^A-Za-z0-9]/', '', $word);
      }
      array_push($words, (string) strtolower(trim($word)));
    }
  }

  return $words;
}

/**
 * Generate a nice url for this petition using pathauto URL cleaning.
 *
 * @param array $petition
 *   Petition result array.
 */
function wh_petitions_generate_nice_url(&$petition) {
  $pattern = variable_get('wh_petitions_nice_url_pattern', WH_PETITION_NICE_URL);

  // Generate path using the pathauto configuration.
  module_load_include('inc', 'pathauto');
  $alias = token_replace($pattern, array('petition' => $petition), array(
    'clear' => TRUE,
    'callback' => 'pathauto_clean_token_values',
  )) . '/' . wh_petitions_generate_hash(8);

  if (_wh_petitions_nice_url_exists($alias, $petition)) {
    $separator = variable_get('pathauto_separator', '-');
    $original_alias = $alias;

    $i = 0;
    do {
      // Append an incrementing numeric suffix until we find a unique alias.
      $alias = $original_alias . $separator . $i;
      $i++;
    } while (_wh_petitions_nice_url_exists($alias, $petition));
  }

  $petition['nice_url'] = $alias;
}

/**
 * Generate URL obfuscation string.
 *
 * Generate a random 8-char hash to append to the end of the
 * url for obfuscation.
 *
 * @param int $length
 *   Length of random string
 */
function wh_petitions_generate_hash($length = 8) {
  $characters = 'bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ0123456789';
  $count = mb_strlen($characters) - 1;
  $hash = '';

  for ($i = 0; $i < $length; $i++) {
    $hash .= $characters[mt_rand(0, $count)];
  }

  return $hash;
}

/**
 * Check to see if the same alias exists for a different Petition.
 */
function _wh_petitions_nice_url_exists($alias, $petition) {
  $collection = wh_petitions_mongo_petition_connection();

  $query = array('nice_url' => $alias);
  if (isset($petition['_id'])) {
    $query['_id'] = array('$ne' => $petition['_id']);
  }

  $petitions = $collection->find($query);
  return $petitions->count() > 0;
}

/**
 * Generate a short url for this petition.
 */
function wh_petitions_generate_short_url(&$petition) {
  if (empty($petition['nice_url'])) {
    wh_petitions_generate_nice_url($petition);
  }
  $petition['short_url'] = wh_petition_tool_shortenurl($petition['nice_url']);
}

/**
 * Returns a default petition object.
 */
function wh_petitions_default_petition() {
  $petition = array(
    // Drupal UID of the creator.
    'uid'               => 0,

    // Display title of the petition.
    'title'             => '',

    // Array of words from the title for searching.
    'title_keywords'    => array(),

    // The body/description of the petition.
    'body'              => '',

    // Array of words from the body for searching.
    'body_keywords'     => array(),

    // Array of previous petition object ids;
    // only admins can edit a non-draft petition.
    'body_revisions'    => array(),

    // Array of taxonomy term IDs.
    'issues'            => array(),

    // Array of taxonomy term IDs for user-submitted keywords.
    'user_tags'         => array(),

    // Array of taxonomy term IDs for private admin-added keywords.
    'private_tags'      => array(),

    // Array of Mongo IDs of related petitions.
    'related_petitions' => array(),

    // State of the petition: public, private, in review, reviewed.
    'petition_status'   => 0,

    // State of the response: none, presidential, etc.
    'response_status'   => 0,

    // Timestamp for when this petition was published.
    'published'         => 0,

    // Timestamp for when this petition reached 'make-public' threshold.
    'reached_public'    => 0,

    // Timestamp for when this petition reached review threshold.
    'reached_ready'     => 0,

    // Timestamp for when this petition was responded to.
    'closed'            => 0,

    // Count of signatures.
    'signature_count'   => 0,

    // Drupal UIDs of people who have flagged this as abuse.
    'abuse_flags'       => array(),

    // Number of days a petition has to reach X signatures and receive a review.
    'review_timeframe'  => 0,

    // Number of signatures required to receive a response.
    'response_signatures' => 0,

    // Number of signatures needed to become public.
    'public_signatures' => 0,

    // Array of Drupal UID's of people who have bookmarked this.
    'bookmarked'        => array(),

    // Whether this is a featured petition ( 0 or 1 ).
    'featured'          => 0,

    // Whether this petition has been removed from lists.
    'hidden'            => 0,

    // Nice url to display the petition detail page at.
    'nice_url'          => '',

    // WH.gov shorturl.
    'short_url'         => '',

    // Timestamp for when petition was created.
    'created'           => 0,
  );

  return $petition;
}

/**
 * Log admin activity (removing/re-enabling) on petitions or signatures.
 *
 * @param object $acting_user
 *   The drupal user object of the admin
 * @param string $entity_type
 *   String of type of entity
 * @param object $entity_acted_upon
 *   the petition or signature object the admin acted upon
 *
 * @return Int
 *   Mongo id of log entry
 */
function wh_petitions_admin_log($acting_user, $entity_type, $entity_acted_upon) {
  // Get collection.
  try {
    $collection = mongodb_collection('admin_log');
  }
  catch (Exception $e) {
    petitionslog_event('exception.wh_petitions.3bc99b3');
  }

  switch ($entity_type) {
    case 'petition':
      $status = $entity_acted_upon['petition_status'];
      break;

    case 'petition_signature':
      $status = $entity_acted_upon['status'];
      break;

    default:
      $status = $entity_acted_upon['status'];
      watchdog('WH Petitions', 'Unknown entity_type (%type) in !file::!line',
        array(
          '%type' => $entity_type,
          '!file' => __FILE__,
          '!line' => __LINE__,
        )
      );
  }

  // Build log entry.
  $entry = array(
    'uid'         => $acting_user->uid,
    'timestamp'   => time(),
    'entity_type' => $entity_type,
    'entity_id'   => $entity_acted_upon['_id'],
    'status'      => $status,
  );

  $collection->save($entry);

  return $entry['_id']->__toString();
}

/**
 * Invoke petition signature observer.
 *
 * Wrapper for invoking all the functionality that needs to be triggered
 * when a petition is signed.
 *
 * @param int $petition_id
 *   The id of the petition being signed.
 * @param int $user_id
 *   The id of the user signing the petition.
 * @param string $ip_address
 *   (optional) The IP address from which the user is signing the petition.
 * @param string $user_agent
 *   (optional) The user agent string of the signer's browser.
 *
 * @return bool
 *   TRUE on success, FALSE otherwise
 */
function wh_petitions_sign_petition($petition_id, $user_id, $ip_address = '', $user_agent = '') {

  // Setup connections for signatures and petitions.
  $connection = wh_petitions_mongo_petition_connection();
  $connection->setSlaveOkay(FALSE);
  $sig_connection = wh_petitions_mongo_petition_signatures_connection();
  $sig_connection->setSlaveOkay(FALSE);

  $slim_petition_elements = array(
    'petition_status',
    'signature_count',
    'response_signatures',
    'public_signatures',
  );

  // Load the petition.
  $petition = wh_petitions_load_slim_petition($connection, $petition_id, $slim_petition_elements);

  // If it wasn't a valid petition id, exit.
  if (empty($petition)) {
    return FALSE;
  }

  // Load user.
  $user = user_load($user_id);

  if (!wh_petitions_create_signature($petition, $user, $sig_connection, $ip_address, $user_agent)) {
    watchdog('wh_petitions', 'Failed to create signature for @user on @petition', array('@user' => $user->uid, '@petition' => $petition['_id']));
    return FALSE;
  };

  // Up the signature_count on the petition.
  wh_petitions_increment_signature_count($petition, $connection);

  /*
   * Check for GovDelivery list and add the topic id if it wasn't
   * in the petition object previously.
   */
  $topic_title = 'petitions_' . $petition['_id']->__toString();
  $topic_id = '';

  // Add their email to GovDelivery.
  govdelivery_subscriber_api_add_subscriber($user->mail, $topic_title, $topic_id);
}

/**
 * Create and save a signature object for the given user and petition.
 *
 * @param object $petition
 *   The petition object being signed.
 * @param object $user
 *   The user object signing the petition.
 * @param MongoClient $signature_collection_connection
 *   Connection to be used for querying and storing the signature.
 * @param string $ip_address
 *   (optional) The IP address from which the user is signing the petition.
 * @param string $user_agent
 *   (optional) The user agent string of the signer's browser.
 * @param int $timestamp
 *   Time when signature was signed. If FALSE, defaults to time().
 *
 * @return string
 *   ID of created signature or FALSE on failure.
 */
function wh_petitions_create_signature($petition, $user, $signature_collection_connection, $ip_address = '', $user_agent = '', $timestamp = FALSE) {
  // If petition is being signed through simplified signing, skip validation
  // checks confirming petition is signable, defer to signatures_queue module's
  // preprocess and process checks.
  $active_signing_method = variable_get('petitions_signing_method', NULL);
  if ($active_signing_method != WH_PETITIONS_SIGNING_METHOD_SIMPLIFIED_SIGNING) {
    // Simplified signing is not enabled. Perform legacy validation checks
    // before counting signature. Can only sign petitions that are open--that
    // is, private, public, or under review.
    if ($petition['petition_status'] != WH_PETITION_STATUS_PRIVATE && $petition['petition_status'] != WH_PETITION_STATUS_PUBLIC && $petition['petition_status'] != WH_PETITION_STATUS_UNDER_REVIEW) {
      watchdog('wh_petitions', 'Unable to create signature on @petition due to invalid petition status (@status).', array(
        '@petition' => $petition['_id'],
        '@status' => $petition['petition_status'],
      ));
      return FALSE;
    }
  }

  // Check if signature_id exists.
  if ($signature_id = wh_petitions_get_signature_id($petition['_id'], $user->uid)) {
    watchdog('wh_petitions', 'unable to create signature, user @user has already signed @petition', array('@petition' => $petition['_id'], '@user' => $user->uid));
    return FALSE;
  }

  // Load the profile for this user
  // @todo: refactor this to not bomb if profile2 isn't installed.
  $profile = profile2_load_by_user($user);
  $fields = array('first_name', 'last_name', 'city', 'state', 'zip', 'country');
  $user_fields = array();
  foreach ($fields as $f) {
    if (!empty($profile['main']->{'field_' . $f}[LANGUAGE_NONE][0]['value'])) {
      $user_fields[$f] = $profile['main']->{'field_' . $f}[LANGUAGE_NONE][0]['value'];
    }
  }

  // Sign the petition without a comment.
  $signature_count = $petition['signature_count'] + 1;
  $signature = array(
    'petition_id' => (string) $petition['_id'],
    'timestamp'   => ($timestamp) ? $timestamp : (int) time(),
    'ip_address'  => (string) $ip_address,
    'user_agent'  => (string) $user_agent,
    'comment'     => '',
    'uid'         => (int) $user->uid,
    'abuse_flags' => array(),
    'status'      => 1,
    'number'      => $signature_count,
    'user'        => array_merge($user_fields, array('username' => $user->name)),
  );

  return wh_petitions_save_signature($signature);
}

/**
 * Increment signature_count of a petition.
 *
 * Increment the signature_count of a petition and check to see
 * if has passed any milestones.
 *
 * @param array $petition
 *   The petition object which will will be incremented
 * @param MongoClient $connection
 *   A connection to the petition dataset
 */
function wh_petitions_increment_signature_count(&$petition, $connection = FALSE) {
  $connection->update(
    array('_id' => $petition['_id']),
    array('$inc' => array('signature_count' => 1))
  );

  $slim_petition_elements = array(
    'petition_status',
    'signature_count',
    'response_signatures',
    'public_signatures',
    'uid',
  );

  $petition = wh_petitions_load_slim_petition($connection, $petition['_id'], $slim_petition_elements);

  // Update to public petition.
  $reached_response = FALSE;
  if ($petition['petition_status'] == WH_PETITION_STATUS_PRIVATE && $petition['signature_count'] == $petition['public_signatures']) {
    $connection->update(
      array('_id' => $petition['_id']),
      array('$set' => array('petition_status' => (int) WH_PETITION_STATUS_PUBLIC, 'reached_public' => (int) time()))
    );
  }
  // Record the time the petition became eligible for a response.
  elseif ($petition['petition_status'] == WH_PETITION_STATUS_PUBLIC && $petition['signature_count'] == $petition['response_signatures']) {
    $connection->update(
      array('_id' => $petition['_id']),
      array(
        '$set' => array(
          'petition_status' => (int) WH_PETITION_STATUS_UNDER_REVIEW,
          'response_status' => (int) WH_PETITION_RESPONSE_STATUS_PENDING,
          'reached_ready' => (int) time(),
        ),
      )
    );
    $reached_response = TRUE;
  }

  // Email the creator if the petition is ready for a response.
  if ($reached_response && petitions_data_mongo_reads_are_enabled()) {
    wh_petitions_email_ready_response($petition['_id']->__toString(), $petition['uid']);
  }

  // Reload petition object.
  $petition = wh_petitions_load_slim_petition($connection, $petition['_id'], $slim_petition_elements);
}

/**
 * Unpublish a single node from Mongo.
 *
 * @param int $legacy_id
 *   ID identifier from MongoDB.
 */
function wh_petitions_mongo2mysql_hide($legacy_id) {
  global $user;
  $petition = NULL;
  if (!empty($legacy_id)) {
    $conn = wh_petitions_mongo_petition_connection();
    $petition = wh_petitions_load_petition($conn, $legacy_id);
    $petition['petition_status'] = WH_PETITION_STATUS_FLAGGED;

    wh_petitions_save_petition($conn, $petition);
    // Log the activity to the admin_log collection.
    wh_petitions_admin_log($user, 'petition', $petition);
  }

  return $petition;
}

/**
 * Publish a single node from Mongo.
 *
 * @param int $legacy_id
 *   ID identifier from MongoDB.
 */
function wh_petitions_mongo2mysql_show($legacy_id) {
  global $user;
  $petition = NULL;

  if (!empty($legacy_id)) {
    $conn = wh_petitions_mongo_petition_connection();
    $petition = wh_petitions_load_petition($conn, $legacy_id);

    // Check to see what Status it should have.
    $timestamp = strtotime('- ' . $petition['review_timeframe'] . ' days');

    if ($petition['published'] < $timestamp) {
      $petition['petition_status'] = WH_PETITION_STATUS_CLOSED;
    }
    elseif ($petition['signature_count'] < $petition['public_signatures']) {
      $petition['petition_status'] = WH_PETITION_STATUS_PRIVATE;
    }
    elseif ($petition['signature_count'] < $petition['response_signatures']) {
      $petition['petition_status'] = WH_PETITION_STATUS_PUBLIC;
    }
    elseif ($petition['signature_count'] >= $petition['response_signatures']) {
      $petition['petition_status'] = WH_PETITION_STATUS_UNDER_REVIEW;
      $petition['response_status'] = WH_PETITION_RESPONSE_STATUS_PENDING;
    }

    wh_petitions_save_petition($conn, $petition);
    $text = t('Hide from Site');

    // Log the activity to the admin_log collection.
    wh_petitions_admin_log($user, 'petition', $petition);
  }

  return $petition;
}

/**
 * Implements hook_admin_paths().
 */
function wh_petitions_admin_paths() {
  $paths = array(
    'remove-mongo-petition' => TRUE,
  );
  return $paths;
}
