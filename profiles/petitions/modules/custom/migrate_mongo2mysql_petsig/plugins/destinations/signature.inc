<?php

/**
 * @file
 * Extend the entity destination class with signature specific info.
 */

class MigrateDestinationSignatureEntity extends MigrateDestinationEntity {

  /**
   * Overloading the constructor.
   */
  public function __construct() {
    parent::__construct("petition", NULL);
  }

  /**
   * Provide the schema for the signature ID.
   *
   * @return array
   *   The schema definition of the ID for a signature
   */
  static public function getKeySchema() {
    return array(
      'id' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'description' => 'ID of destination signature entity',
      ),
    );
  }

  /**
   * Return the fields that are part of a signature.
   *
   * @param object $migration
   *   the migration object
   *
   * @return array
   *   keyed array with the machine name and label of each relevant field
   *   array('machine_name' => "Human readable name", ...)
   */
  public function fields($migration = NULL) {
    $fields = array();

    $schema = drupal_get_schema_unprocessed("signature", "signature_mail");

    foreach ($schema['fields'] as $property => $info) {
      $fields[$property] = $info['description'];
    }

    $fields += migrate_handler_invoke_all('Entity', 'fields', $this->entityType, $this->bundle, $migration);

    return $fields;
  }

  /**
   * Save the date of one object from the source.
   *
   * @param object $signature
   *   entity object generated by migrate
   * @param object $row
   *   raw data coming from the data source
   *
   * @return array
   *   an array of ids from the saved data or FALSE if something goes wrong
   */
  public function import(stdClass $signature, stdClass $row) {
    $this->prepare($signature, $row);

    $id = entity_save("signature_mail", $signature);

    $this->complete($signature, $row);
    if ($id == FALSE) {
      return FALSE;
    }
    else {
      return array($signature->id);
    }
  }

  /**
   * Overloading prepare method.
   */
  public function prepare($entity, stdClass $source_row) {
    parent::prepare($entity, $source_row);

    if (isset($entity->user_first_name)) {
      $entity->user_first_name = substr(migrate_mongo2mysql_sanitize_output(replace4byte($entity->user_first_name)), 0, 255);
    }

    if (isset($entity->user_last_name)) {
      $entity->user_last_name = substr(migrate_mongo2mysql_sanitize_output(replace4byte($entity->user_last_name)), 0, 255);
    }

    if (isset($entity->user_city)) {
      $entity->user_city = substr(migrate_mongo2mysql_sanitize_output(replace4byte($entity->user_city)), 0, 255);
    }

    if (isset($entity->user_state)) {
      $entity->user_state = substr(migrate_mongo2mysql_sanitize_output(replace4byte($entity->user_state)), 0, 255);
    }

    if (isset($entity->user_zip)) {
      $entity->user_zip = substr(migrate_mongo2mysql_sanitize_output(replace4byte($entity->user_zip)), 0, 255);
    }

    if (isset($entity->user_country)) {
      $entity->user_country = substr(migrate_mongo2mysql_sanitize_output(replace4byte($entity->user_country)), 0, 255);
    }

  }

  /**
   * Delete a batch of entities at once.
   *
   * @param array $ids
   *   Array of entity IDs to be deleted.
   */
  public function bulkRollback(array $ids) {
    migrate_instrument_start('entity_delete_multiple');
    $this->prepareRollback($ids);
    entity_delete_multiple('signature_mail', $ids);
    $this->completeRollback($ids);
    migrate_instrument_stop('entity_delete_multiple');
  }
}
